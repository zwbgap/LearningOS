### **数值类型**
Rust 使用一个相对传统的语法来创建整数（1，2，...）和浮点数（1.0，1.1，...）。整数、浮点数的运算和其它语言一致，都是通过常见的运算符来完成。

不仅仅是数值类型，Rust 也允许在复杂类型上定义运算符，例如在自定义类型上定义 + 运算符，这种行为被称为运算符重载。
#### **整数类型**
| 长度 &nbsp;| 有符号类型 |无符号类型|
| :----   |:----| :---- |
| 8位    | i8  | u8  |
| 16位   | i16 | u16  |
| 32位   | i32 | u32  |
| 64位   | i64 | u64  |
| 128位  | i128 | u128  |
|视架构而定|isize|usize|
类型定义的形式统一为：有无符号 + 类型大小(位数)。当要强调符号时，数字前面可以带上正号或负号；有符号数字以补码形式存储。

每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。

整形字面量可以用下表的形式书写：

|数字字面量    |示例   |
| :----        | :----      |
|十进制        |98_222     |
|十六进制      |	0xff   |
|八进制        |	0o77   |
|二进制	       |0b1111_0000|
|字节(仅限于u8)|b'A'       |
 Rust 整型默认使用 i32，例如 let i = 1，那 i 就是 i32 类型，因此你可以首选它，同时该类型也往往是性能最好的。isize 和 usize 的主要应用场景是用作集合的索引。

##### **整数溢出**
当整数类型的值超出了它的范围时，Rust 会进行截断处理。当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。

在当使用 --release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

- 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 - wrapping_add
- 如果使用 checked_* 方法时发生溢出，则返回 None 值
- 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 saturating_* 方法使值达到最小值或最大值
下面是一个演示wrapping_*方法的示例：
```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b); //19
}
```