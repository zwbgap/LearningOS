### **数值类型**
Rust 使用一个相对传统的语法来创建整数（1，2，...）和浮点数（1.0，1.1，...）。整数、浮点数的运算和其它语言一致，都是通过常见的运算符来完成。

不仅仅是数值类型，Rust 也允许在复杂类型上定义运算符，例如在自定义类型上定义 + 运算符，这种行为被称为运算符重载。
#### **整数类型**
| 长度 &nbsp;| 有符号类型 |无符号类型|
| :----   |:----| :---- |
| 8位    | i8  | u8  |
| 16位   | i16 | u16  |
| 32位   | i32 | u32  |
| 64位   | i64 | u64  |
| 128位  | i128 | u128  |
|视架构而定|isize|usize|
类型定义的形式统一为：有无符号 + 类型大小(位数)。当要强调符号时，数字前面可以带上正号或负号；有符号数字以补码形式存储。

每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。

整形字面量可以用下表的形式书写：

|数字字面量    |示例   |
| :----        | :----      |
|十进制        |98_222     |
|十六进制      |	0xff   |
|八进制        |	0o77   |
|二进制	       |0b1111_0000|
|字节(仅限于u8)|b'A'       |
 Rust 整型默认使用 i32，例如 let i = 1，那 i 就是 i32 类型，因此你可以首选它，同时该类型也往往是性能最好的。isize 和 usize 的主要应用场景是用作集合的索引。

##### **整数溢出**
当整数类型的值超出了它的范围时，Rust 会进行截断处理。当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。

在当使用 --release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

- 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 - wrapping_add
- 如果使用 checked_* 方法时发生溢出，则返回 None 值
- 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 saturating_* 方法使值达到最小值或最大值

下面是一个演示wrapping_*方法的示例：
```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b); //19
}
#### **浮点类型**
在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。

下面是一个演示浮点数的示例：
```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```
浮点数根据 IEEE-754 标准实现。f32 类型是单精度浮点型，f64 为双精度。f32 的精度通常是足够的，但是在一些情况下 f64 的精度更高，例如在大型或者需要高精度小数的科学计算中。
##### **浮点数陷阱**
由于浮点数底层格式的特殊性，浮点数运算会出现一些奇怪的情况可能会造成危险，例如：
1. **浮点数往往是你想要数字的近似表达** 
浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行

2. **浮点数在某些特性上是反直觉的**
例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 >，>= 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

```rust
fn main() {
    let x = 0.1 + 0.2;
    println!("{}", x == 0.3); //false
    assert!(x == 0.3); //panic
}
```
Output:
```rust
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2', src\main.rs:29:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 == 0.3 通过测试，但是到了 f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾，这个细微区别导致 f64 下的测试失败了，并且抛出了异常。
##### **NAN**
NAN 是一个特殊的浮点数，它代表非数字（Not a Number），它不等于任何数值，包括它自己。NAN 通常用于表示一个未定义的或者无效的值，例如当你尝试将一个字符串转换为数字时，如果转换失败，Rust 会返回 NAN。

对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。

所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃：
```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```
出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN ：
```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert!(x.is_nan());
}
```
#### **数字运算**
Rust 的数字运算与其它语言类似。
```Rust
fn main() {
    // 加法
    let sum = 5 + 10;
    // 减法
    let difference = 95.5 - 4.3;
    // 乘法
    let product = 4 * 30;
    // 除法
    let quotient = 56.7 / 32.2;
    // 求余
    let remainder = 43 % 5;
}
```

#### **位运算**
|运算符|	说明|
|:--|:--|
|& 位与|相同位置均为1时则为1，否则为0|
|\| 位或|相同位置只要有1时则为1，否则为0|
|^ 异或|相同位置不相同则为1，相同则为0|
|! 位非|把位中的0和1相互取反，即0置为1，1置为0|
|<< 左移|所有位向左移动指定位数，右位补0|
|>> 右移|所有位向右移动指定位数，带符号移动（正数补0，负数补1）|
示例：
```rust
fn main() {
    // 二进制为00000010
    let a:i32 = 2;
    // 二进制为00000011
    let b:i32 = 3;

    println!("(a & b) value is {}", a & b);

    println!("(a | b) value is {}", a | b);

    println!("(a ^ b) value is {}", a ^ b);

    println!("(!b) value is {} ", !b);

    println!("(a << b) value is {}", a << b);

    println!("(a >> b) value is {}", a >> b);

    let mut a = a;
    // 注意这些计算符除了!之外都可以加上=进行赋值 (因为!=要用来判断不等于)
    a <<= b;
    println!("(a << b) value is {}", a);
}
```

#### **序列**
Rust 也支持序列类型，例如元组和数组。元组是一个固定长度的序列，数组是一个固定长度且同类型的序列。

Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..=5，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：
```rust
for i in 1..=5 {
    println!("{}",i);
}
```
```rust
Output:
1
2
3
4
5
```
序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。

如下是一个使用字符类型序列的例子：
```rust
for i in 'a'..='z' {
    println!("{}",i);
}
```
#### **使用As完成类型转换**
Rust 中的类型转换是通过 as 关键字完成的，其最常用于将原始类型转换为其他原始类型，但是它也可以完成诸如将指针转换为地址、地址转换为指针以及将指针转换为其他指针等功能。

#### **有理数和负数**
Rust 的标准库相比其它语言，准入门槛较高，因此有理数和复数并未包含在标准库中：

- 有理数和复数
- 任意大小的整数和任意精度的浮点数
- 固定精度的十进制小数，常用于货币相关的场景
  
按照以下步骤可引入 num 库：

创建新工程 `cargo new complex-num && cd complex-num`
在 `Cargo.toml` 中的 `[dependencies]` 下添加一行 `num = "0.4.0"`
将 `src/main.rs` 文件中的 `main` 函数替换为下面的代码
运行 `cargo run`
```rust
use num::complex::Complex;

 fn main() {
   let a = Complex { re: 2.1, im: -1.2 };
   let b = Complex::new(11.1, 22.2);
   let result = a + b;

   println!("{} + {}i", result.re, result.im)
 }
```
#### **总结**
Rust 的基本类型包括：数值类型、字符串、布尔类型、字符类型、单元类型。Rust 的类型推导非常强大，但是有时候我们需要标注变量的类型，这样做的好处是可以提高代码的可读性，同时也可以为编译器提供更多的信息，帮助编译器更好的进行类型检查。

- **Rust 拥有相当多的数值类型.**
因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数
- **类型转换必须是显式的.**
Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数
- **Rust 的数值上可以使用方法.**
例如你可以用以下方法来将 13.14 取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道 13.14 的具体类型