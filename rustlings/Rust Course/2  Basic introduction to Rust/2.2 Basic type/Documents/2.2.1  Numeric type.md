### **数值类型**
Rust 使用一个相对传统的语法来创建整数（1，2，...）和浮点数（1.0，1.1，...）。整数、浮点数的运算和其它语言一致，都是通过常见的运算符来完成。

不仅仅是数值类型，Rust 也允许在复杂类型上定义运算符，例如在自定义类型上定义 + 运算符，这种行为被称为运算符重载。
#### **整数类型**
| 长度 &nbsp;| 有符号类型 |无符号类型|
| :----   |:----| :---- |
| 8位    | i8  | u8  |
| 16位   | i16 | u16  |
| 32位   | i32 | u32  |
| 64位   | i64 | u64  |
| 128位  | i128 | u128  |
|视架构而定|isize|usize|
类型定义的形式统一为：有无符号 + 类型大小(位数)。当要强调符号时，数字前面可以带上正号或负号；有符号数字以补码形式存储。

每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 n 是该定义形式的位长度。因此 i8 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 u8 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。

整形字面量可以用下表的形式书写：

|数字字面量    |示例   |
| :----        | :----      |
|十进制        |98_222     |
|十六进制      |	0xff   |
|八进制        |	0o77   |
|二进制	       |0b1111_0000|
|字节(仅限于u8)|b'A'       |
 Rust 整型默认使用 i32，例如 let i = 1，那 i 就是 i32 类型，因此你可以首选它，同时该类型也往往是性能最好的。isize 和 usize 的主要应用场景是用作集合的索引。

##### **整数溢出**
当整数类型的值超出了它的范围时，Rust 会进行截断处理。当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 panic(崩溃,Rust 使用这个术语来表明程序因错误而退出)。

在当使用 --release 参数进行 release 模式构建时，Rust 不检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（two’s complement wrapping）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。

要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：

- 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 - wrapping_add
- 如果使用 checked_* 方法时发生溢出，则返回 None 值
- 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 saturating_* 方法使值达到最小值或最大值

下面是一个演示wrapping_*方法的示例：
```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b); //19
}
#### **浮点类型**
在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。默认浮点类型是 f64，在现代的 CPU 中它的速度与 f32 几乎相同，但精度更高。

下面是一个演示浮点数的示例：
```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```
浮点数根据 IEEE-754 标准实现。f32 类型是单精度浮点型，f64 为双精度。f32 的精度通常是足够的，但是在一些情况下 f64 的精度更高，例如在大型或者需要高精度小数的科学计算中。
##### **浮点数陷阱**
由于浮点数底层格式的特殊性，浮点数运算会出现一些奇怪的情况可能会造成危险，例如：
1. **浮点数往往是你想要数字的近似表达** 
浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行

2. **浮点数在某些特性上是反直觉的**
例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 >，>= 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

```rust
fn main() {
    let x = 0.1 + 0.2;
    println!("{}", x == 0.3); //false
    assert!(x == 0.3); //panic
}
```
Output:
```rust
abc (f32)
   0.1 + 0.2: 3e99999a
         0.3: 3e99999a

xyz (f64)
   0.1 + 0.2: 3fd3333333333334
         0.3: 3fd3333333333333

thread 'main' panicked at 'assertion failed: xyz.0 + xyz.1 == xyz.2', src\main.rs:29:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
对 f32 类型做加法时，0.1 + 0.2 的结果是 3e99999a，0.3 也是 3e99999a，因此 f32 下的 0.1 + 0.2 == 0.3 通过测试，但是到了 f64 类型时，结果就不一样了，因为 f64 精度高很多，因此在小数点非常后面发生了一点微小的变化，0.1 + 0.2 以 4 结尾，但是 0.3 以3结尾，这个细微区别导致 f64 下的测试失败了，并且抛出了异常。
##### **NAN**
NAN 是一个特殊的浮点数，它代表非数字（Not a Number），它不等于任何数值，包括它自己。NAN 通常用于表示一个未定义的或者无效的值，例如当你尝试将一个字符串转换为数字时，如果转换失败，Rust 会返回 NAN。

对于数学上未定义的结果，例如对负数取平方根 -42.1.sqrt() ，会产生一个特殊的结果：Rust 的浮点数类型使用 NaN (not a number)来处理这些情况。

所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较，下面的代码会崩溃：
```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```
出于防御性编程的考虑，可以使用 is_nan() 等方法，可以用来判断一个数值是否是 NaN ：
```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert!(x.is_nan());
}
```
#### **数字运算**
Rust 的数字运算与其它语言类似。
```Rust
fn main() {
    // 加法
    let sum = 5 + 10;
    // 减法
    let difference = 95.5 - 4.3;
    // 乘法
    let product = 4 * 30;
    // 除法
    let quotient = 56.7 / 32.2;
    // 求余
    let remainder = 43 % 5;
}
```